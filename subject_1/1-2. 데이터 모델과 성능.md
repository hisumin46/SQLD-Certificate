## 1-1.  데이터 모델과 성능

### 성능 모델링

- DB 성능 향상을 위해 데이터 모델링 단계부터 정규화, 반정규화, 테이블 통합/분리, 조인, PK/FK 등 여러가지 사항이 모델레 반영되게 함

#### 성능 데이터 모델링 고려사항 순서

1. 데이터 모델링 **정규화**
2. DB **용량**산정
3. DB에 발생되는 **트랜잭션** 유형 파악
4. 용량과 트랜잭션의 유형에 따라 **반정규화**
5. 이력모델의 조정, PK/FK조정, 슈퍼/서브타입 조정
6. 성능관점에서 데이터 모델을 검증

### 정규화

- 데이터 일관성, 최소한의 데이터 중복, 최대한의 유연성을 위한 방법
- 데이터르ㅡㄹ 분해하는 과정
- 데이터 중복제거, 데이터 모델의 독립성 

#### 정규화 절차

- **1차 정규화**: 속성의 원자성 확보, 기본키 설정, 중복 제거
- **2차 정규화**: 기본키가 2개 이상속성으로 이루어진 경우 → 부분 함수 종속성 제거(분해)
- **3차 정규화**: 기본키를 제외한 컬럼 간 이행함수 종속성 제거
- 4차 정규화: 여러 컬럼들이 하나의 컬럼을 종속시키는경우 → 분헤 → 다중 값 종속성 제거
- 5차 정규화: 조인에 의해 종속성 발생 → 분해
- BCNF: 기본키를 제외하고 후보키가 있는경우, 후보키가 기본키를 종속시키면서 분해

#### 정규화의 문제점

- 데이터 조회 `SELECT`시 조인을 유발 → CPU, 메모리 많이 사용

### 반정규화

- DB 성능 향상을 위하여 데이터 중복 허용 → 조인을 줄임
- 조회속도↑, 데이터 모델의 유연성↓

#### 반정규화 절차
1. 대상 조사 및 검토 → 데이터 처리 범위, 빈도수, 통계성
2. 다른 방법 검토 → 뷰, 클러스터링, 인덱스 조정, 응용프로그램, 파티션
3. 반정규화 수행 → 테이블, 속성, 관계 등 반정규화

#### 클러스터링
- 인덱스 정보를 저장할때 물리적으로 정렬하여 저장
- 조회시 인접 블록을 연속적으로 읽기 때문에 성능 향상

#### 반정규화 수행하는 경우
- 정규화에 너무 충실 → 조인이 많아 조회 느림
- 다량의 범위를 자주 처리해야되는 경우
- 특정 범위의 데이터만 자주 처리해야되는 경우
- 통계, 집계 정보가 자주 요구되는 경우
- **Sorting, Order by 반정규화 대상 X**

#### 다른 방법 검토
- 지나치게 많은 조인이 걸려 조회하는 작업이 기술적으로 어려울경우 → 뷰
- 대량의 데이터 처리나 부분 처리에 의 해 성능 정하 → 클러스터링, 인덱스 조정
- 대량의 데이터는 PK 의 성격에 따라 부분적으로 테이블 분리 → 파티셔닝
- 응용 프로그램에서 로직 변경하여 성능 향상

#### 반정규화 기법 - [테이블] 테이블 병합
- 1:1 관계를 하나의 테이블로 병합
- 1:M 관계를 하나읱 테이블로 병합
- 슈퍼/서브 관계를 통합

#### 반정규화 기법 - [테이블] 테이블 분할
- 수직분할: 하나의 테이블을 두개 이상의 테이블로 분할(컬럼 기준으로 1:1)
- 수평분할: 하나의 테이블에 있는 값을 기준으로 분할(행 기준으로 분리)

#### 반정규화 기법 - [테이블] 테이블 추가

- `중복 테이블 추가`
  - 다른 업무이거나 서버가 다른 경우
  - 동일한 테이블 구조를 중복하여 원격 조인을 제거하여 성능 향상
- `통계 테이블 `추가
  - SUM, AVG 등을 미리 계산하여 조회하여 성능 향상
- `이력 테이블 추가`
  - 이력테이블 중에서 마스터 테이블에 존재하는 행을 중복하여 이력테이블에 존재시켜 성능 향상
- `부분 테이블 추가`
  - 한 테이블의 전체 컬럼중 자주 이용하는 컬럼이 있을때 I/O 를 줄이기 위해 해당 컬럼들을 모아놓은 별도의 반정규화 테이블 생성

#### 반정규화 기법 - [컬럼] 

- `중복컬럼`
  - 조인에 의한 처리로 성능이 저하될걸 예방하여 테이블에 중복된 컬럼 위치
- `파생컬럼`
  - 트랜잭션이 처리되는 시점에, 계산에 의해 성능저하 예방
  - 미리 값을 계산하여 컬럼에 저장
- `이력 테이블 컬럼`
  - 대량 이력데이터를 처리할때 불특정 일자 조회, 최근값을 조회할대 나타나는 성능 저하 예방
  - 이력테이블에 컬럼 추가(최근값 여부, 시작과 종료일자)
- `PK에 의한 컬럼 추가`
  - PK에 데이터가 존재하지만 성능 향상을 위해 일반 속성으로 포함하는 경우
- `응용시스템 오작동을 위한 컬럼 추가`
  - 업무적으로는 의미가 없지만 사용자의 실수로 원래 값으로 복구하기 원하는 경우 이전 데이터를 임시적으로 중복하여 보관

#### 반정규화 기법 - [관계]

- `중복관계 추가`
  - 데이터 처리를 위한 조인이 여러 경로를 거쳐 발생될경우 성능 저하를 예방하기 위한 추가적인 관계를 생성해줌
- `로우 체이닝`
  - 행의 길이가 너무 길어서 데이터 블록 하나에 데이터가 모두 저장되지 않음
  - 두개이상에 블록에 걸쳐 하나의 행이 저장되어있는 형태
- `로우 마이그레이션`
  - 데이터블록에서 수정이 발생하면 수정된 데이터를 해당 데이터 블록에서 저장하지 못하고 다른 블록의 빈 공간을 찾아 저장
- 로우 체이닝, 마이그레이션이 발생하면 많은 디스트 I/O 발생 → 성능 저하
- 트랜잭션을 분석하여 적절하게 1:1 관계로 분리

#### 파티셔닝 기법

- 파티션을 사용하여 테이블 분할
- 논리적으로는 하나의 테이블이지만 여러개 데이터 파일에 분산되어 저장
- `RANGE`
  - 대상 테이블이 날짜 또는 숫자값으로 분리 가능
  - 각 영역별로 트랜잭션이 분리되는 경우
- `LIST`
  - 지점, 사업소 등처럼 코드값으로 PK 구성
  - 대량의 데이터가 있는 테이블
- `HASH`
  - HASH 조건에 따라 해쉬 알고리즘 적용되어 테이블 분리
- 장점
  - 데이터 조회시 접근 범위가 줄어들어 성능 향상
  - 데이터가 분할되어 이씩에 I/O 성능 향상
  - 각 파이션을 독립적으로 백업,복구 가능

#### 테이블에 대한 수평/수직분할 절차

1. 데이터 모델링 완성
2. DB 용량산정 수행
3. 대량 데이터가 처리되는 데이블에 대해 트랜잭션 처리 분석
4. 칼럼/로우 단위로 집중화된 처리 분석 →  집중화된 단위로 테이블을 분리하는 것을 검토


### 슈퍼타입과 서비타입

- 엔티티들의 공통 부분은 슈퍼타임
- 공통으로부터 상속받아 다른 엔터티와 차이가 있는 속성에 대해서는 별도의 서브엔터티로 구분
- ex: 고객 - 개인고객/ 법인 고객은 서비스타입
- 즉 부모와 자식간의 관걔를 나타냄

#### 슈퍼/서브 타입 데이터 모델 변환

- 변환 잘못 → 성능 저하 이유는 트랜잭션틔 특성을 고려하지 않고 테이블 설계했기 때문
- 트랜잭션은 항상 **일괄**로 처리하는데 테이블은 개별로 되어있다면 UNION 연산에 의해 성능 저하
- 트랜잭션은 항상 **서브타입을 개별**로 처리하느데 테이블이 하나로 통합되어있다면 성능저하
- 트랜잭션은 항상 **슈퍼+서브타입을 공통**으로 처리하는데 갭렬로 유지되어있거나 하나의 테이블로 되어있으면 성능 저하

#### 슈퍼타입 및 서브타입 변환 방법

- OneToOne Type
  - 슈퍼타입과 서브타입을 개별 테이블로
  - 테이블수가 많아져 조인 발생, 관리 어려움
- Plus Type
  - 슈퍼+서브 테이블
  - 조인 발생, 관리 어려움
- Single Type / All in One Type
  - 슈퍼타입과 서버타임을 하나의 테이블로 도출
  - 조인 성능이 좋고 관리가 편하지만 I/O 성능 나쯤

### 인덱스 관련 PF/FK 성능
- 인덱스 구성시 앞쪽에 위치한 속성같이 `=` 이거나 최소한의 범위 `BETWEEN`, `!=` 가 들어와야지 효율적임
- 물리적인 테이블에 PK 제약을 걸었을때 반드시 PK 인덱스 생성
- FK 제약이 걸리지 않은 경우는 FK인덱스 생성하는것은 기본정책이지만 발생되는 트랜잭션에 의해 활동하지 않을때는 FK인덱스 지워도 됨
- 즉 PK는 인덱스가 자동 생성 / FK에도 인덱스를 생성하긴 해야됨

### 분산 데이터 베이스

- 여러 곳으로 분산되어 있는 DB를 하나의 가상 시스템으로 사용할 수 있도록 한 DB
- 논리적으로 동일 시스템에 속하지만 컴퓨터 네트워크를 통해 물리적으로 분산되어 있는 데이터 집합

#### 분산 데이터베이스 투명성

- `분할 투명성(단편화)`: 하나의 논리적 relation 이 여러 단으로 분할되어 사본이 여러 site에 저장
- `위치 투명성`: 사용하는 데이터의 장소가 명시적으로 표현될 필요 없이 위치정보 카탈로그에 유지
- `지역사상 투명성`: 지역 DBMS와 물리적 DB 사이에 사상이 보장되어야됨
- `중복 투명성`: DB 객체가 여러 시스템에 중복 되어도 데이터 일관성 유지
- `장애 투명성`: 지역의 시스템이나 통신망에 이상이 발생해도 데이터의 무결성은 보장되어야 함
- `볗행 투명성`: 여러 사용자가 동시에 분산 DB에 대한 트랜잭션을 수행해도 결과에 이상이 없어야 함

#### 분산 데이터 설계 방식

- 상향식: 지역 → 전역
- 하향식: 지역 ← 전역

#### 분산 데이터베이스 장단점

- 장점: 지역 자치성, 신뢰성, 가용성, 융통성, 빠른 응답속도, 각 지역 사용자 요구 수용, 시스템 용량 확장이 쉬움
- 단점: : 관리와 통제가 어려움, 오류의 잠재성 증대, 설계가 복잡함, 데이터 무결성 관리가 어려움, 보안 관리가 어려움

#### 분산 DB 적용 기법

- 테이블 위치 분산: 설계된 테이블을 본사/지사단위로 분산
- 테이블 분할 분산: 각각의 테이블을 쪼개어 분산
  - 수평분할 : 로우(행) 단위로 분리
  - 수직분할 : 칼럼 단위로 분리
- 테이블 복제 분산: 동일한 테이블을 다른 지역이나 서버에서 동시에 생성하여 관리하는 유형
- 부분복제: 마스터 DB에서 테이블의 일부의 내용만 다른 지역이나 서버에 위치
- 광역복제:  마스터 DB 테이블의 내용을 각 지역이나 서버에 존재
- 테이블 요약 분산: 지역 간 / 서버 간에 데이터가 비슷하지만 서로 다른 유형으로 존재하는 경우
- 분석요약: 동일한 테이블 구조를 가지고 있으면서 분산되어 있는 동일한 내용의 데이터를 이용하여 통합된 데이터를 산출
- 통합요약: 분산되어 있는 다른 내용의 데이터를 이용하여 통합된 데이터를 산출
- GIS(Global Single Instance) : 통합데이터 구조

#### 분산 데이터베이스 설계 고려 이유
- 성능이 중요한 site
- 공통코드, 기준정보, 마스터의 성능 향상
- 거의 실시간의 업무적 특징을 갖는 경우
- 특정 서버에 부하가 집중되어 부하 분산해야되는 경우
- 백업 사이트 구성할 경우